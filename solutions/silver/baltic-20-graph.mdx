---
id: baltic-20-graph
source: Baltic OI
title: 2020 - Graph
author: David Zhou
---

[Official Analysis](https://codeforces.com/blog/entry/80525)

## Explanation

### Constraint Propagation

Suppose the value of one endpoint of an edge is $u$. If $u + v = s$, then we can find the value of the other endpoint to be $v = s - u$. Based on this, if we fix one node's value in a connected component, all other values in that component are determined by following the edges.

### Determining General Values of Nodes

For each connected component, we can express all node values in terms of a single variable $x$:

- We start with an arbitrary node and set its value to $x$
- Then we propagate through the edges. If $u = ax + b$ and edge $(u,v)$ has sum $s$, then $v = s - u = -ax + (s - b)$

This means that every node is represented in the form of $ax + b$.

### Checking Feasibility in Cyclic Connected Components

We encounter a cycle when we visit an already-visited node. This means that we need to check for feasibility.
- If we reach node $u$ again, we have two expressions for it
- The cycle gives us an equation in terms of $x$
- If the equation has no solution or contradicts a previous solution, the problem is infeasible

<Spoiler title="Why Cycle Equations Determine x">
Consider a path from node $u$ back to itself. Let $u = a_1x + b_1$, our starting value for propagation. At some point later on, if we loop back, we will get another expression of $u = a_2x + b_2$.

**Case 1:** $a_1 = a_2$: We get $b_1 = b_2$. If $b_1 \neq b_2$, the connected component is infeasible, so the entire graph is infeasible.

**Case 2:** $a_1 \neq a_2$: We can solve: $x = \dfrac{b_2-b_1}{a_1 - a_2}$, uniquely determining a value for $x$.
</Spoiler>

### Acyclic Connected Components

When no cycle determines $x$, we must choose its value to minimize the expression: $\sum_{i=1}^n |a_i x + b_i|$. This can be done by setting $x$ to the median of the roots.

<Spoiler title="Why Median Minimizes Sum">
We want to minimize the function $f(x) = \sum_{i=1}^n |a_i x + b_i|$.

Since each $a_i \in \{+1, -1\}$, we can rewrite each term as $|a_i x + b_i| = |x - r_i|$, where $r_i = -\dfrac{b_i}{a_i}$

Thus, minimizing $f(x)$ is equivalent to minimizing $f(x) = \sum_{i=1}^n |x - r_i|$  

Intuitively, we can think of trying to push $x$ as close to the middle of the roots as possible, as placing it there will "balance" the values.

Mathematically, we can fix any $x \in \mathbb{R}$ and a small positive increment $h > 0$ so that no $r_i$ lies in the interval $(x, x + h]$.

Consider the change
$f(x + h) - f(x) = \sum_{i=1}^{k} (|x + h - r_i| - |x - r_i|)$.

For each $i$, one of two things happens:
- If $r_i \le x$, then $|x + h - r_i| - |x - r_i| = h$.
- If $r_i > x$, then $|x + h - r_i| - |x - r_i| = -h$.

Therefore, $f(x + h) - f(x) = h \cdot(\# {\{i : r_i \le x\}} - \# {\{i : r_i > x\}})$.

Let $L(x) = \# {\{i : r_i \le x\}}$ and $R(x) = \# {\{i : r_i > x\}}$.
Note that $L(x) + R(x) = n$.

If $L(x) < R(x)$ then $f(x + h) - f(x) < 0$, so moving slightly to the right decreases $g$.

If $L(x) > R(x)$ then $f(x + h) - f(x) > 0$, so moving slightly to the right increases $g$. Equivalently, moving to the left decreases $g$.

If $L(x) = R(x)$ then $f(x + h) = f(x)$. moves do not affect the value of $g$.

Therefore, the only possible minima occur at points where $L(x) \ge R(x)$ and $R(x) \ge L(x)$. This means either $L(x) = R(x)$ or moving in either direction leaves the counts balanced. This is true at the median of the roots.

</Spoiler>

### Determining Actual Values of Nodes

Regardless of how we computed $x$, once we have it, we need to propagate this value throughout the connected components. We can plug $x$ into each $ax + b$ and determine the exact value of each node that minimizes the sum of their absolute values.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log N + M)$

<LanguageSection>

<CPPSection>

```cpp
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;
using pll = pair<ll, ll>;

const ll INF = 1e18;

vector<vector<pll>> adj;
vector<pll> coeffs;  // each node value is represented as ax + b (stored as pair {a, b})
vector<bool> vis;
vector<double> ans;
vector<int> current_component;
bool impossible;
ll current_val;

void dfs(int u) {
    current_component.push_back(u);
    vis[u] = true;

    for (auto [v, w] : adj[u]) {
        if (vis[v]) {
            // found a cycle -> check consistency or solve for x
            pll res = {coeffs[u].first + coeffs[v].first,
                       coeffs[u].second + coeffs[v].second};

            if (res.first == 0) {
                // x terms cancel -> check if constants match
                if (res.second != w) {
                    impossible = true;
                }
            } else {
                // can solve for x
                ll expected;
                if (res.first == 2) {
                    expected = w - res.second;
                } else {
                    expected = res.second - w;
                }
                if (current_val == INF) {
                    current_val = expected;
                } else if (current_val != expected) {
                    // contradiction with previously determined x
                    impossible = true;
                    return;
                }
            }
        } else {
            // compute neighbor's value based on edge: v = w - u
            coeffs[v] = {-coeffs[u].first, w - coeffs[u].second};
            dfs(v);
        }
    }
}

void propagate(int u) {
    // once x is known, propagate actual values through component
    vis[u] = true;
    for (auto [v, w] : adj[u]) {
        if (!vis[v]) {
            ans[v] = w - ans[u];
            propagate(v);
        }
    }
}

double find_median(const vector<int>& comp) {
    // optimal x minimizes sum of |ax+b|, which occurs at median of roots
    vector<ll> roots;
    for (int node : comp) {
        if (coeffs[node].first == 1) {
            roots.push_back(-coeffs[node].second);
        } else {
            roots.push_back(coeffs[node].second);
        }
    }
    sort(roots.begin(), roots.end());
    int sz = roots.size();
    return (roots[(sz - 1) / 2] + roots[sz / 2]) / 2.0;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    adj.resize(n);
    coeffs.assign(n, {-INF, -INF});
    vis.assign(n, false);
    ans.resize(n);
    impossible = false;

    // build adjacency list
    for (int i = 0; i < m; i++) {
        int a, b;
        ll c;
        cin >> a >> b >> c;
        --a, --b;
        adj[a].push_back({b, c});
        adj[b].push_back({a, c});
    }

    vector<vector<int>> components;
    vector<ll> component_vals;

    // find all connected components
    for (int i = 0; i < n; i++) {
        if (!vis[i]) {
            current_component.clear();
            current_val = INF;
            coeffs[i] = {1, 0};  // let first node = x
            dfs(i);
            components.push_back(current_component);
            component_vals.push_back(current_val);
        }
    }

    if (impossible) {
        cout << "NO\n";
        return 0;
    }

    cout << "YES\n";
    fill(vis.begin(), vis.end(), false);

    // compute final values for each component
    for (int i = 0; i < components.size(); i++) {
        int start = components[i][0];
        if (component_vals[i] == INF) {
            // x not fixed -> use median for optimal sum
            ans[start] = find_median(components[i]);
        } else {
            // x was determined by a cycle
            ans[start] = component_vals[i] / 2.0;
        }
        propagate(start);
    }

    for (int i = 0; i < n; i++) {
        cout << fixed << setprecision(1) << ans[i];
        if (i == n - 1) {
            cout << '\n';
        } else {
            cout << ' ';
        }
    }
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Graph {
    static final long INF = (long) 1e18;
    
    static List<List<Pair>> adj;
    static List<Pair> coeffs;  // each node value is represented as ax + b (stored as pair {a, b})
    static boolean[] vis;
    static double[] ans;
    static List<Integer> currentComponent;
    static boolean impossible;
    static long currentVal;
    
    static class Pair {
        long first, second;
        Pair(long first, long second) {
            this.first = first;
            this.second = second;
        }
    }
    
    static void dfs(int u) {
        currentComponent.add(u);
        vis[u] = true;
        
        for (Pair edge : adj.get(u)) {
            int v = (int) edge.first;
            long w = edge.second;
            
            if (vis[v]) {
                // found a cycle -> check consistency or solve for x
                Pair res = new Pair(
                    coeffs.get(u).first + coeffs.get(v).first,
                    coeffs.get(u).second + coeffs.get(v).second
                );
                
                if (res.first == 0) {
                    // x terms cancel -> check if constants match
                    if (res.second != w) impossible = true;
                } else {
                    // can solve for x
                    long expected;
                    if (res.first == 2) {
                        expected = w - res.second;
                    } else {
                        expected = res.second - w;
                    }
                    if (currentVal == INF) {
                        currentVal = expected;
                    } else if (currentVal != expected) {
                        // contradiction with previously determined x
                        impossible = true;
                        return;
                    }
                }
            } else {
                // compute neighbor's value based on edge: v = w - u
                coeffs.set(v, new Pair(-coeffs.get(u).first, w - coeffs.get(u).second));
                dfs(v);
            }
        }
    }
    
    static void propagate(int u) {
        // once x is known, propagate actual values through component
        vis[u] = true;
        for (Pair edge : adj.get(u)) {
            int v = (int) edge.first;
            long w = edge.second;
            if (!vis[v]) {
                ans[v] = w - ans[u];
                propagate(v);
            }
        }
    }
    
    static double findMedian(List<Integer> comp) {
        // optimal x minimizes sum of |ax+b|, which occurs at median of roots
        List<Long> roots = new ArrayList<>();
        for (int node : comp) {
            if (coeffs.get(node).first == 1) {
                roots.add(-coeffs.get(node).second);
            } else {
                roots.add(coeffs.get(node).second);
            }
        }
        Collections.sort(roots);
        int sz = roots.size();
        return (roots.get((sz - 1) / 2) + roots.get(sz / 2)) / 2.0;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        
        adj = new ArrayList<>();
        coeffs = new ArrayList<>();
        vis = new boolean[n];
        ans = new double[n];
        impossible = false;
        
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
            coeffs.add(new Pair(-INF, -INF));
        }
        
        // build adjacency list
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken()) - 1;
            int b = Integer.parseInt(st.nextToken()) - 1;
            long c = Long.parseLong(st.nextToken());
            adj.get(a).add(new Pair(b, c));
            adj.get(b).add(new Pair(a, c));
        }
        
        List<List<Integer>> components = new ArrayList<>();
        List<Long> componentVals = new ArrayList<>();
        
        // find all connected components
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                currentComponent = new ArrayList<>();
                currentVal = INF;
                coeffs.set(i, new Pair(1, 0));  // let first node = x
                dfs(i);
                components.add(new ArrayList<>(currentComponent));
                componentVals.add(currentVal);
            }
        }
        
        if (impossible) {
            pw.println("NO");
            pw.close();
            return;
        }
        
        pw.println("YES");
        Arrays.fill(vis, false);
        
        // compute final values for each component
        for (int i = 0; i < components.size(); i++) {
            int start = components.get(i).get(0);
            if (componentVals.get(i) == INF) {
                // x not fixed -> use median for optimal sum
                ans[start] = findMedian(components.get(i));
            } else {
                // x was determined by a cycle
                ans[start] = componentVals.get(i) / 2.0;
            }
            propagate(start);
        }
        
        for (int i = 0; i < n; i++) {
            pw.printf("%.1f", ans[i]);
            if (i == n - 1) {
                pw.println();
            } else {
                pw.print(" ");
            }
        }
        
        pw.close();
    }
}
```

</JavaSection>

</LanguageSection>